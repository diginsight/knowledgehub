---
title: "How to Create MCP Servers for GitHub Copilot"
author: "Dario Airoldi"
date: "2026-01-21"
categories: [tech, prompt-engineering, github-copilot, mcp]
description: "Learn how to build custom Model Context Protocol (MCP) servers that extend GitHub Copilot with new tools, resources, and integrations using TypeScript, C#, or Python."
---

# How to Create MCP Servers for GitHub Copilot

The <mark>**Model Context Protocol (MCP)**</mark> enables you to extend GitHub Copilot with <mark>custom tools, resources, and integrations</mark> that go far beyond what's possible with prompts, agents, or skills alone.  
While the previous articles in this series covered **consuming** Copilot customizations, this article focuses on **creating** your own MCP serversâ€”building the server-side components that provide new capabilities to Copilot Chat.

This article covers MCP server architecture, implementation patterns in <mark>TypeScript</mark>, <mark>C#</mark>, and <mark>Python</mark>, and best practices for debugging and deployment.

## Table of Contents

- [ğŸ¯ Understanding MCP servers](#-understanding-mcp-servers)
- [ğŸ—ï¸ MCP server architecture](#ï¸-mcp-server-architecture)
  - [SDK implementations compared](#sdk-implementations-compared)
- [ğŸ”§ Building tools](#-building-tools)
- [ğŸ“¦ Building resources](#-building-resources)
- [ğŸ’» Implementation: TypeScript](#-implementation-typescript)
- [ğŸ’» Implementation: C# (.NET)](#-implementation-c-net)
- [ğŸ’» Implementation: Python](#-implementation-python)
- [âš™ï¸ Configuration and registration](#ï¸-configuration-and-registration)
- [ğŸ§ª Testing and debugging](#-testing-and-debugging)
- [ğŸš€ Deployment patterns](#-deployment-patterns)
- [âš ï¸ Common pitfalls](#ï¸-common-pitfalls)
- [ğŸ’¡ Decision framework](#-decision-framework)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

# ğŸ¯ Understanding MCP servers

## What is the Model Context Protocol?

<mark>**MCP (Model Context Protocol)**</mark> is an open standard that defines how AI assistants communicate with external tools and data sources.  
Think of it as a <mark>**universal adapter**</mark>â€”rather than building custom integrations for each AI assistant, you build one MCP server that works with any MCP-compatible client.

### Key concepts

| Concept | Description |
|---------|-------------|
| **<mark>MCP Server</mark>** | A process that provides tools, resources, and prompts to AI clients |
| **<mark>MCP Client</mark>** | An AI assistant (like <mark>Copilot</mark>) that connects to servers to access capabilities |
| **<mark>Tools</mark>** | <mark>Functions</mark> the AI can call to perform actions (query databases, call APIs, etc.) |
| **<mark>Resources</mark>** | <mark>Data sources</mark> the AI can read (files, configurations, live data) |
| **<mark>Prompts</mark>** | Reusable prompt templates exposed by the server |
| **<mark>Transport</mark>** | Communication channel (stdio, SSE/HTTP) between client and server |

### MCP vs other customization types

| Feature | MCP Servers | Skills | Agents | Prompts |
|---------|-------------|--------|--------|---------|
| **<mark>Purpose</mark>** | Add <mark>tools</mark> and <mark>data sources</mark> | Bundle workflows with resources | Define AI personas | Define reusable tasks |
| **<mark>Scope</mark>** | Unlimited (any integration) | File-based workflows | Chat session behavior | Single task execution |
| **<mark>Language</mark>** | Any (<mark>TypeScript</mark>, <mark>C#</mark>, <mark>Python</mark>, etc.) | Markdown only | Markdown only | Markdown only |
| **<mark>Complexity</mark>** | High (full programming) | Medium (folder structure) | Low (single file) | Low (single file) |
| **<mark>Capabilities</mark>** | Call APIs, query DBs, execute code | Read files, run scripts | Control tools, handoff | Variable substitution |
| **<mark>Cross-platform</mark>** | âœ… Any MCP client | âœ… VS Code, CLI, coding agent | âŒ VS Code only | âŒ VS Code only |

### When to build an MCP server

**âœ… Build an MCP server when you need to:**

- <mark>**Query external systems**</mark> â€” Databases, APIs, internal services
- <mark>**Perform complex computations**</mark> â€” Data processing, analysis, transformations
- <mark>**Access live data**</mark> â€” Real-time metrics, monitoring, dashboards
- <mark>**Enforce business logic**</mark> â€” Validation rules, compliance checks
- <mark>**Integrate proprietary tools**</mark> â€” Internal tooling, legacy systems
- <mark>**Share capabilities across projects**</mark> â€” Reusable tooling for teams

**âŒ Don't build an MCP server when:**

- A prompt file can accomplish the task
- You only need to define coding standards (use instruction files)
- You only need to bundle scripts with instructions (use skills)
- The existing built-in tools or community servers meet your needs

# ğŸ—ï¸ MCP server architecture

## Server lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. INITIALIZATION                                              â”‚
â”‚  â”œâ”€â”€ Client discovers server (from mcp.json configuration)      â”‚
â”‚  â”œâ”€â”€ Client spawns server process                               â”‚
â”‚  â””â”€â”€ Server sends capabilities (tools, resources, prompts)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. CAPABILITY NEGOTIATION                                      â”‚
â”‚  â”œâ”€â”€ Client: "What can you do?"                                 â”‚
â”‚  â”œâ”€â”€ Server: Lists tools with JSON Schema definitions           â”‚
â”‚  â””â”€â”€ Server: Lists resources and prompt templates               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. RUNTIME OPERATION                                           â”‚
â”‚  â”œâ”€â”€ Client sends tool invocation requests                      â”‚
â”‚  â”œâ”€â”€ Server executes tool logic                                 â”‚
â”‚  â”œâ”€â”€ Server returns structured results                          â”‚
â”‚  â””â”€â”€ (Repeat for each tool call)                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. SHUTDOWN                                                    â”‚
â”‚  â””â”€â”€ Client terminates server process                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Transport options

MCP supports two primary transport mechanisms:

| Transport | Use Case | Pros | Cons |
|-----------|----------|------|------|
| **<mark>stdio</mark>** | Local servers | Simple, secure, fast | Single client only |
| **<mark>SSE/HTTP</mark>** | Remote servers | Multiple clients, network accessible | Requires authentication |

<mark>**For GitHub Copilot integration, stdio is the default and recommended transport**</mark>. The client spawns your server as a subprocess and communicates via stdin/stdout.

## Message format

<mark>MCP</mark> uses <mark>JSON-RPC 2.0</mark> for all communication:

```json
// Tool invocation request (client â†’ server)
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/call",
  "params": {
    "name": "query_database",
    "arguments": {
      "table": "users",
      "filter": "active = true"
    }
  }
}

// Tool result response (server â†’ client)
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "Found 42 active users..."
      }
    ]
  }
}
```

## SDK implementations compared

A critical question when building MCP servers is: **How do the different language implementations compare?** This section clarifies the execution model and capabilities across TypeScript, C#, and Python SDKs.

### Process model: out-of-process, not in-process

<mark>**All MCP servers run as separate processes**</mark>â€”they are **never** loaded in-process into the AI client (like VS Code or Claude Desktop). This is a fundamental architectural decision:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MCP HOST (e.g., VS Code, Claude Desktop)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  MCP Client 1  â”‚  â”‚  MCP Client 2  â”‚  â”‚  MCP Client 3  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                   â”‚                   â”‚
     stdio/HTTP          stdio/HTTP          stdio/HTTP
           â”‚                   â”‚                   â”‚
           â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MCP Server      â”‚  â”‚  MCP Server      â”‚  â”‚  MCP Server      â”‚
â”‚  (TypeScript)    â”‚  â”‚  (Python)        â”‚  â”‚  (C#/.NET)       â”‚
â”‚  SEPARATE PROCESSâ”‚  â”‚  SEPARATE PROCESSâ”‚  â”‚  SEPARATE PROCESSâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Why out-of-process?**

| Benefit | Explanation |
|---------|-------------|
| **<mark>Language independence</mark>** | Write servers in any languageâ€”the client doesn't care |
| **<mark>Isolation</mark>** | Server crashes don't affect the host application |
| **<mark>Security</mark>** | Servers run with their own permissions and sandboxing |
| **<mark>Scalability</mark>** | Multiple servers can run simultaneously |
| **<mark>Updates</mark>** | Update servers independently of the client |

### Communication: transport is the same

Regardless of which SDK you use, communication with the client uses identical protocols:

| Transport | How it works | Language support |
|-----------|--------------|------------------|
| **<mark>stdio</mark>** | Client spawns server as subprocess, communicates via stdin/stdout | âœ… All SDKs |
| **<mark>Streamable HTTP</mark>** | Server runs as HTTP endpoint, client connects via POST/SSE | âœ… All SDKs |

<mark>**Key insight**: The client doesn't know or care what language your server is written in.</mark> A TypeScript client can connect to a Python server, and a C# host can spawn a TypeScript serverâ€”the JSON-RPC 2.0 messages are identical.

### Capability parity: same MCP primitives everywhere

All official SDKs implement the **same MCP specification** and expose the **same primitives**:

| Capability | TypeScript | C# (.NET) | Python | Notes |
|------------|------------|-----------|--------|-------|
| **Tools** | âœ… | âœ… | âœ… | Functions AI can call |
| **Resources** | âœ… | âœ… | âœ… | Read-only data sources |
| **Prompts** | âœ… | âœ… | âœ… | Reusable templates |
| **Sampling** | âœ… | âœ… | âœ… | Request LLM completions from client |
| **Elicitation** | âœ… | âœ… | âœ… | Request user input |
| **Notifications** | âœ… | âœ… | âœ… | Real-time updates to client |
| **Progress reporting** | âœ… | âœ… | âœ… | Long-running operation status |
| **Structured output** | âœ… | âœ… | âœ… | Typed tool responses (spec 2025-06-18) |

**Bottom line**: You can expose the exact same functionality regardless of which SDK you choose.

### SDK-specific differences: ecosystem and ergonomics

While capabilities are identical, each SDK has unique strengths based on its language ecosystem:

| Aspect | TypeScript | C# (.NET) | Python |
|--------|------------|-----------|--------|
| **Runtime** | Node.js | .NET 8.0+ | Python 3.10+ |
| **Package manager** | npm | NuGet | pip/uv |
| **Async model** | Promises, async/await | Task-based async | asyncio |
| **Type safety** | Optional (TypeScript) | Strong (compile-time) | Optional (type hints) |
| **Startup time** | Fast (< 100ms) | Medium (cold start ~200ms) | Fast (< 100ms) |
| **Memory footprint** | Medium | Higher (CLR overhead) | Lower |
| **Best for** | Web integrations, npm ecosystem | Enterprise, existing .NET codebases | AI/ML, data science |

**Ergonomic differences:**

```typescript
// TypeScript: Decorator-free, functional style
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  // Handle tool call
});
```

```csharp
// C#: Attribute-based, dependency injection
[McpServerTool, Description("Tool description")]
public string MyTool(string input) => $"Result: {input}";
```

```python
# Python: Decorator-based, FastMCP convenience layer
@mcp.tool()
def my_tool(input: str) -> str:
    return f"Result: {input}"
```

### Choosing your implementation language

Use this decision framework:

| If you need... | Choose... | Because... |
|---------------|-----------|------------|
| **Quick prototyping** | Python (FastMCP) | Minimal boilerplate, decorator syntax |
| **npm ecosystem access** | TypeScript | Direct integration with npm packages |
| **Enterprise integration** | C# (.NET) | Strong typing, dependency injection, ASP.NET integration |
| **AI/ML capabilities** | Python | Rich libraries (PyTorch, transformers, etc.) |
| **Existing .NET codebase** | C# (.NET) | Seamless integration with existing services |
| **Maximum type safety** | C# (.NET) or TypeScript | Compile-time error checking |
| **Smallest deployment** | Python or TypeScript | No CLR overhead |

**Remember**: The choice is about developer experience and ecosystem, not capabilities. All three can do everything MCP supports.

# ğŸ”§ Building tools

<mark>Tools</mark> are the primary way MCP servers provide functionality to AI clients. Each tool has:

1. **<mark>Name</mark>** â€” Unique identifier (e.g., `query_database`)
2. **<mark>Description</mark>** â€” What the tool does (helps AI decide when to use it)
3. **<mark>Input Schema</mark>** â€” JSON Schema defining required and optional parameters
4. **<mark>Handler</mark>** â€” Function that executes when the tool is called

## Tool definition anatomy

```typescript
// TypeScript example - tool definition
{
  name: "validate_yaml",
  description: "Validates a YAML string and returns any syntax errors",
  inputSchema: {
    type: "object",
    properties: {
      content: {
        type: "string",
        description: "The YAML content to validate"
      },
      strict: {
        type: "boolean",
        description: "Enable strict validation mode",
        default: false
      }
    },
    required: ["content"]
  }
}
```

## Tool design best practices

### 1. Write <mark>descriptive descriptions</mark>

The <mark>AI uses your description to decide when to call your tool</mark>. Be specific about:
- <mark>What</mark> the tool does
- <mark>When</mark> to use it (and when not to)
- <mark>What inputs</mark> it expects
- <mark>What outputs</mark> it returns

```typescript
// âŒ Vague description
description: "Validates content"

// âœ… Specific description
description: "Validates YAML syntax and structure. Use this when checking " +
             "configuration files, CI/CD workflows, or any YAML content for " +
             "syntax errors. Returns detailed error messages with line numbers."
```

### 2. Design <mark>focused</mark>, <mark>single-purpose tools</mark>

Each tool should do one thing well. If you're tempted to add an `action` parameter, split into multiple tools instead.

```typescript
// âŒ Multi-purpose tool
{
  name: "file_operations",
  inputSchema: {
    properties: {
      action: { enum: ["read", "write", "delete", "list"] },
      path: { type: "string" }
    }
  }
}

// âœ… Focused tools
{ name: "read_file", ... }
{ name: "write_file", ... }
{ name: "delete_file", ... }
{ name: "list_directory", ... }
```

### 3. Use proper <mark>JSON Schema for validation</mark>

Leverage JSON Schema features to ensure valid inputs:

```typescript
inputSchema: {
  type: "object",
  properties: {
    email: {
      type: "string",
      format: "email",
      description: "User's email address"
    },
    age: {
      type: "integer",
      minimum: 0,
      maximum: 150
    },
    role: {
      type: "string",
      enum: ["admin", "user", "guest"]
    }
  },
  required: ["email"],
  additionalProperties: false
}
```

### 4. Return <mark>structured, actionable results</mark>

```typescript
// âŒ Unstructured result
return { content: [{ type: "text", text: "Error occurred" }] };

// âœ… Structured, actionable result
return {
  content: [{
    type: "text",
    text: JSON.stringify({
      success: false,
      error: {
        code: "VALIDATION_FAILED",
        message: "Invalid YAML syntax",
        line: 42,
        column: 15,
        suggestion: "Check for missing colon after key name"
      }
    }, null, 2)
  }]
};
```

# ğŸ“¦ Building resources

Resources provide read-only data that the AI can access. Unlike tools (which perform actions), resources expose information.

## Resource types

| Type | URI Pattern | Example |
|------|-------------|---------|
| **Static** | Fixed URI | `config://settings` |
| **Template** | Parameterized URI | `file://{path}` |
| **Dynamic** | Generated at runtime | `metrics://cpu-usage` |

## Resource definition

```typescript
{
  uri: "config://validation-rules",
  name: "Validation Rules",
  description: "Current validation configuration and thresholds",
  mimeType: "application/json"
}
```

# ğŸ’» Implementation: <mark>TypeScript</mark>

<mark>**TypeScript/Node.js**</mark> is the most common language for MCP servers, with excellent SDK support.

## Setup

```bash
# Create new project
mkdir my-mcp-server && cd my-mcp-server
npm init -y

# Install dependencies
npm install @modelcontextprotocol/sdk
npm install -D typescript @types/node

# Initialize TypeScript
npx tsc --init
```

## Basic server structure

```typescript
// src/index.ts
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

// Create server instance
const server = new Server(
  {
    name: "my-mcp-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "greet",
        description: "Generates a greeting message for the given name",
        inputSchema: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Name of the person to greet",
            },
          },
          required: ["name"],
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "greet") {
    const personName = args?.name as string;
    return {
      content: [
        {
          type: "text",
          text: `Hello, ${personName}! Welcome to MCP.`,
        },
      ],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

// Start server with stdio transport
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MCP server running on stdio");
}

main().catch(console.error);
```

## Build and run

```json
// package.json
{
  "name": "my-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js"
  }
}
```

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true
  },
  "include": ["src/**/*"]
}
```

# ğŸ’» Implementation: <mark>C#</mark> (<mark>.NET</mark>)

C# provides strong typing and <mark>excellent performance</mark> for MCP servers. The official SDK is maintained in collaboration with Microsoft.

## Setup

```bash
# Create new console project
dotnet new console -n MyMcpServer
cd MyMcpServer

# Add MCP SDK (official package)
dotnet add package ModelContextProtocol --prerelease
dotnet add package Microsoft.Extensions.Hosting
```

## Basic server structure (attribute-based)

The recommended approach uses attributes and dependency injection:

```csharp
// Program.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Server;
using System.ComponentModel;

var builder = Host.CreateApplicationBuilder(args);

// Configure logging to stderr (required for stdio transport)
builder.Logging.AddConsole(options =>
{
    options.LogToStandardErrorThreshold = LogLevel.Trace;
});

builder.Services
    .AddMcpServer()
    .WithStdioServerTransport()
    .WithToolsFromAssembly();  // Auto-discovers tools in assembly

await builder.Build().RunAsync();

// Define tools using attributes
[McpServerToolType]
public static class GreetingTools
{
    [McpServerTool, Description("Generates a greeting message for the given name")]
    public static string Greet(
        [Description("Name of the person to greet")] string name)
        => $"Hello, {name}! Welcome to MCP.";

    [McpServerTool, Description("Generates a farewell message")]
    public static string Farewell(
        [Description("Name of the person")] string name,
        [Description("Optional custom message")] string? message = null)
        => message ?? $"Goodbye, {name}! See you soon.";
}
```

## Advanced: dependency injection and server access

Tools can access services and the MCP server instance:

```csharp
[McpServerToolType]
public class DataTools
{
    [McpServerTool, Description("Query the database and summarize results")]
    public static async Task<string> QueryDatabase(
        McpServer server,           // Injected: access to MCP server
        HttpClient httpClient,      // Injected: from DI container
        [Description("The query to execute")] string query,
        CancellationToken cancellationToken)
    {
        // Use httpClient from dependency injection
        var data = await httpClient.GetStringAsync($"/api/query?q={query}", cancellationToken);
        
        // Use server to make sampling requests back to client
        var summary = await server.AsSamplingChatClient()
            .GetResponseAsync($"Summarize: {data}", cancellationToken);
        
        return summary;
    }
}
```

## Alternative: low-level handler approach

For fine-grained control over the protocol:

```csharp
using ModelContextProtocol;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;
using System.Text.Json;

McpServerOptions options = new()
{
    ServerInfo = new Implementation { Name = "MyServer", Version = "1.0.0" },
    Handlers = new McpServerHandlers
    {
        ListToolsHandler = (request, ct) =>
            ValueTask.FromResult(new ListToolsResult
            {
                Tools = [
                    new Tool
                    {
                        Name = "greet",
                        Description = "Generates a greeting message",
                        InputSchema = JsonSerializer.Deserialize<JsonElement>("""
                        {
                            "type": "object",
                            "properties": {
                                "name": { "type": "string", "description": "Name to greet" }
                            },
                            "required": ["name"]
                        }
                        """),
                    }
                ]
            }),

        CallToolHandler = (request, ct) =>
        {
            if (request.Params?.Name == "greet")
            {
                var name = request.Params.Arguments?["name"]?.ToString() ?? "World";
                return ValueTask.FromResult(new CallToolResult
                {
                    Content = [new TextContentBlock { Text = $"Hello, {name}!", Type = "text" }]
                });
            }
            throw new McpProtocolException($"Unknown tool: '{request.Params?.Name}'", McpErrorCode.InvalidRequest);
        }
    }
};

await using var server = McpServer.Create(new StdioServerTransport("MyServer"), options);
await server.RunAsync();
```

# ğŸ’» Implementation: <mark>Python</mark>

Python offers quick prototyping and access to rich AI/ML libraries. The SDK includes **FastMCP**, a high-level API that minimizes boilerplate.

## Setup

```bash
# Using uv (recommended)
uv init mcp-server-demo
cd mcp-server-demo
uv add "mcp[cli]"

# Or with pip
pip install "mcp[cli]"
```

## Basic server structure (FastMCPâ€”recommended)

FastMCP provides a decorator-based API for minimal boilerplate:

```python
# server.py
from mcp.server.fastmcp import FastMCP

# Create server instance
mcp = FastMCP("my-mcp-server")

@mcp.tool()
def greet(name: str) -> str:
    """Generates a greeting message for the given name.
    
    Args:
        name: Name of the person to greet
    """
    return f"Hello, {name}! Welcome to MCP."

@mcp.tool()
def add(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

@mcp.resource("config://settings")
def get_settings() -> str:
    """Get application settings."""
    return '{"theme": "dark", "language": "en"}'

@mcp.prompt()
def summarize(content: str) -> str:
    """Generate a summarization prompt."""
    return f"Please summarize the following content:\n\n{content}"

if __name__ == "__main__":
    mcp.run()  # Uses stdio transport by default
```

Run with:
```bash
python server.py
# Or with uv
uv run server.py
```

## Advanced: context access and progress reporting

Tools can access the MCP context for logging, progress, and client interaction:

```python
from mcp.server.fastmcp import FastMCP, Context
from mcp.server.session import ServerSession

mcp = FastMCP("progress-demo")

@mcp.tool()
async def long_task(
    task_name: str, 
    ctx: Context[ServerSession, None],
    steps: int = 5
) -> str:
    """Execute a long-running task with progress updates."""
    await ctx.info(f"Starting: {task_name}")
    
    for i in range(steps):
        progress = (i + 1) / steps
        await ctx.report_progress(
            progress=progress,
            total=1.0,
            message=f"Step {i + 1}/{steps}"
        )
        await ctx.debug(f"Completed step {i + 1}")
    
    return f"Task '{task_name}' completed"
```

## Alternative: low-level server

For full control over the protocol:

```python
import asyncio
from mcp.server.lowlevel import Server
from mcp.server.stdio import stdio_server
import mcp.types as types

server = Server("my-mcp-server")

@server.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="greet",
            description="Generates a greeting message",
            inputSchema={
                "type": "object",
                "properties": {
                    "name": {"type": "string", "description": "Name to greet"}
                },
                "required": ["name"]
            }
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "greet":
        person_name = arguments.get("name", "World")
        return [types.TextContent(type="text", text=f"Hello, {person_name}!")]
    raise ValueError(f"Unknown tool: {name}")

async def main():
    async with stdio_server() as (read, write):
        await server.run(read, write)

if __name__ == "__main__":
    asyncio.run(main())
```

## Running with HTTP transport

For remote deployments, use Streamable HTTP:

```python
if __name__ == "__main__":
    # Streamable HTTP (recommended for production)
    mcp.run(transport="streamable-http", host="0.0.0.0", port=8000)
```

# âš™ï¸ Configuration and registration

## VS Code configuration

MCP servers are registered in VS Code's `settings.json` or workspace `.vscode/mcp.json`:

```json
// .vscode/mcp.json (workspace-level, recommended)
{
  "servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["${workspaceFolder}/mcp-servers/my-server/dist/index.js"]
    }
  }
}
```

```json
// settings.json (user-level)
{
  "github.copilot.chat.mcp.servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["/path/to/my-server/dist/index.js"]
    }
  }
}
```

## Configuration options

| Option | Description | Example |
|--------|-------------|---------|
| `type` | Transport type | `"stdio"` or `"sse"` |
| `command` | Executable to run | `"node"`, `"python"`, `"dotnet"` |
| `args` | Command arguments | `["dist/index.js"]` |
| `env` | Environment variables | `{ "API_KEY": "..." }` |
| `cwd` | Working directory | `"${workspaceFolder}"` |

## Environment variables

<mark>**Never hardcode secrets in your server code**</mark>. Use environment variables:

```json
// .vscode/mcp.json
{
  "servers": {
    "my-server": {
      "type": "stdio",
      "command": "node",
      "args": ["dist/index.js"],
      "env": {
        "DATABASE_URL": "${env:DATABASE_URL}",
        "API_KEY": "${env:MY_API_KEY}"
      }
    }
  }
}
```

# ğŸ§ª Testing and debugging

## MCP Inspector

The <mark>**MCP Inspector**</mark> is the primary debugging tool for MCP servers:

```bash
# Install globally
npm install -g @modelcontextprotocol/inspector

# Run your server through the inspector
mcp-inspector node dist/index.js
```

The inspector provides:
- Live message inspection (requests/responses)
- Tool testing interface
- Resource browser
- Protocol validation

## Logging strategies

Since MCP uses stdio for communication, <mark>**never write to stdout for debugging**</mark>. Use stderr instead:

```typescript
// TypeScript
console.error("Debug: Processing request...");

// Python
import sys
print("Debug: Processing request...", file=sys.stderr)

// C#
Console.Error.WriteLine("Debug: Processing request...");
```

## Unit testing tools

```typescript
// TypeScript example with Jest
describe("greet tool", () => {
  it("returns greeting with name", async () => {
    const result = await handleToolCall("greet", { name: "Alice" });
    
    expect(result.content[0].text).toContain("Hello, Alice");
  });

  it("handles missing name gracefully", async () => {
    await expect(handleToolCall("greet", {}))
      .rejects.toThrow("name is required");
  });
});
```

## Integration testing

```typescript
// Test full server lifecycle
describe("MCP Server", () => {
  let server: Server;
  let transport: TestTransport;

  beforeEach(async () => {
    transport = new TestTransport();
    server = createServer();
    await server.connect(transport);
  });

  it("lists tools correctly", async () => {
    const response = await transport.sendRequest({
      method: "tools/list",
      params: {}
    });
    
    expect(response.tools).toHaveLength(1);
    expect(response.tools[0].name).toBe("greet");
  });
});
```

# ğŸš€ Deployment patterns

## <mark>Local development</mark>

```
.vscode/
â”œâ”€â”€ mcp.json              # Server configuration
â””â”€â”€ settings.json         # Enable MCP

mcp-servers/
â””â”€â”€ my-server/
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ index.ts
    â”œâ”€â”€ dist/             # Compiled output
    â”œâ”€â”€ package.json
    â””â”€â”€ tsconfig.json
```

## <mark>Workspace distribution</mark>

Share servers with your team by including them in the repository:

```
.copilot/
â””â”€â”€ mcp-servers/
    â””â”€â”€ my-server/
        â”œâ”€â”€ dist/         # Pre-compiled binaries
        â””â”€â”€ package.json

.vscode/
â””â”€â”€ mcp.json              # Points to .copilot/mcp-servers/
```

## <mark>Publishing to MCP Registry</mark>

For public distribution, submit your server to the [MCP Registry](https://github.com/modelcontextprotocol/registry):

1. Ensure your server follows the [MCP specification](https://spec.modelcontextprotocol.io/)
2. Add comprehensive documentation
3. Include example configurations
4. Submit a pull request to the registry repository

# âš ï¸ Common pitfalls

## 1. Writing to stdout

<mark>**CRITICAL:**</mark> MCP uses stdout for protocol communication. Any debug output to stdout corrupts the protocol.

```typescript
// âŒ Breaks MCP protocol
console.log("Debug message");

// âœ… Use stderr for debugging
console.error("Debug message");
```

## 2. Synchronous blocking

Long-running operations block the entire server. Always use async patterns:

```typescript
// âŒ Blocks server
function processData(data: string): string {
  // Heavy synchronous processing
  return heavyComputation(data);
}

// âœ… Non-blocking
async function processData(data: string): Promise<string> {
  return await heavyComputationAsync(data);
}
```

## 3. Missing error handling

Unhandled errors crash the server. Wrap tool handlers in try-catch:

```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const result = await handleTool(request.params);
    return result;
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: `Error: ${error.message}`
      }],
      isError: true
    };
  }
});
```

## 4. Vague tool descriptions

The AI relies on descriptions to decide when to use tools. Be specific:

```typescript
// âŒ AI doesn't know when to use this
description: "Processes data"

// âœ… Clear use case
description: "Validates JSON configuration files against a predefined schema. " +
             "Use when checking config.json, settings.json, or similar files. " +
             "Returns detailed validation errors with line numbers."
```

## 5. Overly complex input schemas

Keep inputs simple. If you need many parameters, consider splitting into multiple tools:

```typescript
// âŒ Too many parameters
inputSchema: {
  properties: {
    source: { type: "string" },
    destination: { type: "string" },
    format: { type: "string" },
    compression: { type: "boolean" },
    encryption: { type: "boolean" },
    encryptionKey: { type: "string" },
    // ... many more
  }
}

// âœ… Focused tool with sensible defaults
inputSchema: {
  properties: {
    source: { type: "string" },
    destination: { type: "string" }
  },
  required: ["source", "destination"]
}
```

# ğŸ’¡ Decision framework

Use this flowchart to decide if you need an MCP server:

```
Need to extend Copilot capabilities?
â”‚
â”œâ”€ Just coding standards/rules?
â”‚  â””â”€ Use instruction files (.instructions.md)
â”‚
â”œâ”€ Reusable task with user input?
â”‚  â””â”€ Use prompt files (.prompt.md)
â”‚
â”œâ”€ Persistent AI persona with tool restrictions?
â”‚  â””â”€ Use agent files (.agent.md)
â”‚
â”œâ”€ Cross-platform workflow with scripts/templates?
â”‚  â””â”€ Use skill files (SKILL.md)
â”‚
â”œâ”€ Need to call external APIs or databases?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â”œâ”€ Need real-time data access?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â”œâ”€ Need complex business logic?
â”‚  â””â”€ Build an MCP server âœ…
â”‚
â””â”€ Need to integrate proprietary systems?
   â””â”€ Build an MCP server âœ…
```

# ğŸ¯ Conclusion

Building MCP servers unlocks the full potential of GitHub Copilot by enabling:

- <mark>**Custom tool integrations**</mark> â€” Connect to any API, database, or service
- <mark>**Real-time data access**</mark> â€” Provide live metrics, logs, and status information
- <mark>**Business logic enforcement**</mark> â€” Implement validation, compliance, and domain rules
- <mark>**Cross-platform compatibility**</mark> â€” Work with any MCP-compatible AI assistant

**Key takeaways:**

1. **Start simple** â€” Build one tool, test it thoroughly, then expand
2. **Write clear descriptions** â€” The AI uses them to decide when to call your tools
3. **Use stderr for debugging** â€” Never write to stdout
4. **Handle errors gracefully** â€” Return structured error messages
5. **Test with MCP Inspector** â€” Verify protocol compliance before deployment

MCP servers are the most powerful way to extend Copilot, but they're also the most complex. Use the decision framework above to ensure you're choosing the right customization type for your needs.

# ğŸ“š References

**[Model Context Protocol Specification](https://spec.modelcontextprotocol.io/)** ğŸ“˜ [Official]  
The official MCP specification defining protocol messages, transports, and capabilities. Essential reading for understanding the protocol internals.

**[MCP Architecture Overview](https://modelcontextprotocol.io/docs/concepts/architecture)** ğŸ“˜ [Official]  
Comprehensive guide to MCP architecture covering participants, layers, lifecycle management, and the data/transport separation.

**[MCP Transports Documentation](https://modelcontextprotocol.io/docs/concepts/transports)** ğŸ“˜ [Official]  
Detailed specification of stdio and Streamable HTTP transports, including message framing, session management, and security considerations.

**[MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)** ğŸ“˜ [Official]  
Official TypeScript/Node.js SDK for building MCP servers and clients. Includes examples and type definitions.

**[MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk)** ğŸ“˜ [Official]  
Official Python SDK for building MCP servers. Includes FastMCP high-level API and low-level protocol access.

**[MCP C# SDK](https://github.com/modelcontextprotocol/csharp-sdk)** ğŸ“˜ [Official]  
Official C#/.NET SDK maintained in collaboration with Microsoft. Supports attribute-based tools and ASP.NET Core integration.

**[MCP SDKs Overview](https://modelcontextprotocol.io/docs/sdk)** ğŸ“˜ [Official]  
Complete list of official SDKs (TypeScript, Python, Go, Kotlin, Swift, Java, C#, Ruby, Rust, PHP) with links to documentation.

**[MCP Inspector](https://github.com/modelcontextprotocol/inspector)** ğŸ“˜ [Official]  
Debugging tool for MCP servers. Essential for development and troubleshooting.

**[MCP Server Registry](https://github.com/modelcontextprotocol/registry)** ğŸ“˜ [Official]  
Community registry of published MCP servers. Browse for inspiration or submit your own.

**[VS Code MCP Documentation](https://code.visualstudio.com/docs/copilot/chat/mcp-servers)** ğŸ“˜ [Official]  
VS Code-specific documentation for configuring and using MCP servers with GitHub Copilot.

---

## Related articles in this series

- [01. How GitHub Copilot uses markdown and prompt folders](./02-getting-started/01.00-how_github_copilot_uses_markdown_and_prompt_folders.md) â€” Overview of all customization types
- [03. How to structure content for prompt files](./03.00-how_to_structure_content_for_copilot_prompt_files.md) â€” Referencing MCP tools in prompts
- [04. How to structure content for agent files](./04.00-how_to_structure_content_for_copilot_agent_files.md) â€” Configuring MCP tools for agents
- [06. How to structure content for skill files](./06.00-how_to_structure_content_for_copilot_skills.md) â€” Cross-platform workflows

<!--
validations:
  grammar:
    status: "not_run"
    last_run: null
  readability:
    status: "not_run"
    last_run: null
  structure:
    status: "not_run"
    last_run: null
  fact_check:
    status: "not_run"
    last_run: null
  logic:
    status: "not_run"
    last_run: null

article_metadata:
  filename: "07. how_to_create_mcp_servers_for_copilot.md"
  word_count: ~2800
  created: "2026-01-20"
  series: "Prompt Engineering for GitHub Copilot"
  series_order: 7
-->

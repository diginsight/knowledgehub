---
title: "How to Manage Information Flow During Prompt Orchestrations"
author: "Dario Airoldi"
date: "2026-01-25"
categories: [tech, github-copilot, prompt-engineering, orchestration, information-flow]
description: "Master information flow between prompts, agents, instructions, tools, and MCP servers with strategies for robustness, effectiveness, and token efficiency"
---

# How to Manage Information Flow During Prompt Orchestrations

When orchestrating complex AI workflows, <mark>**information flow is everything**</mark>.  
The most sophisticated prompt architecture fails if critical context doesn't reach the right component at the right time.  
This article provides a comprehensive guide to managing information flow across all GitHub Copilot customization componentsâ€”prompts, agents, instructions, tools, MCP servers, and prompt-snippets.

You'll learn how to design communication strategies that balance <mark>**robustness**</mark> (information doesn't get lost), <mark>**effectiveness**</mark> (the right information reaches the right place), and <mark>**token efficiency**</mark> (minimal context window consumption).

## Table of Contents

- [ğŸ¯ Why information flow matters](#-why-information-flow-matters)
- [ğŸ—ï¸ Information flow architecture](#ï¸-information-flow-architecture)
  - [The context window as communication bus](#the-context-window-as-communication-bus)
  - [Component roles in information flow](#component-roles-in-information-flow)
- [ğŸ“¡ Communication pathways](#-communication-pathways)
  - [Prompt â†’ Agent communication](#prompt--agent-communication)
  - [Agent â†’ Agent (handoffs)](#agent--agent-handoffs)
  - [Instructions integration](#instructions-integration)
  - [Tool invocations and results](#tool-invocations-and-results)
  - [Terminal command boundaries](#terminal-command-boundaries)
  - [VS Code tasks and terminal commands](#vs-code-tasks-and-terminal-commands)
  - [MCP server communication](#mcp-server-communication)
  - [Prompt-snippet inclusion](#prompt-snippet-inclusion)
- [ğŸ“Š Communication strategies comparison](#-communication-strategies-comparison)
  - [Strategy comparison matrix](#strategy-comparison-matrix)
  - [Token efficiency analysis](#token-efficiency-analysis)
  - [Robustness comparison](#robustness-comparison)
- [ğŸ”§ Implementation patterns](#-implementation-patterns)
  - [Pattern 1: <mark>Full context handoff</mark>](#pattern-1-full-context-handoff)
  - [Pattern 2: <mark>Progressive summarization</mark>](#pattern-2-progressive-summarization)
  - [Pattern 3: <mark>File-based isolation</mark>](#pattern-3-file-based-isolation)
  - [Pattern 4: <mark>User-mediated handoff</mark>](#pattern-4-user-mediated-handoff)
  - [Pattern 5: <mark>Structured report passing</mark>](#pattern-5-structured-report-passing)
- [âš ï¸ Common pitfalls and solutions](#ï¸-common-pitfalls-and-solutions)
- [ğŸ’¡ Best practices and guidelines](#-best-practices-and-guidelines)
- [ğŸ¯ Conclusion](#-conclusion)
- [ğŸ“š References](#-references)

---

# ğŸ¯ Why information flow matters

## The context problem

Every interaction with an AI model operates within a <mark>**context window**</mark>â€”a limited space where all relevant information must coexist.  
In simple single-prompt scenarios, managing context is straightforward.  
But in multi-agent orchestrations with handoffs, tool calls, and MCP integrations, information flow becomes the critical success factor.

### The three failure modes

| Failure Mode | Symptom | Root Cause |
|--------------|---------|------------|
| **<mark>Context Loss</mark>** | Agent doesn't know about earlier decisions | Handoff didn't transfer critical context |
| **<mark>Context Bloat</mark>** | Responses become slow, expensive, or confused | Too much irrelevant context accumulated |
| **<mark>Context Conflict</mark>** | Agent receives contradictory instructions | Multiple sources provide conflicting guidance |

### The goal

Design information flow that ensures:

1. âœ… **Right information** reaches each component
2. âœ… **Minimal tokens** consumed for context transfer
3. âœ… **No critical data** lost during transitions
4. âœ… **Clear priority** when multiple sources provide guidance

---

# ğŸ—ï¸ Information flow architecture

## The context window as communication bus

Think of the context window as a <mark>**shared communication bus**</mark> where all components must place their messages.  
Every prompt, instruction, tool result, and MCP response competes for space in this limited channel.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CONTEXT WINDOW (128K-200K tokens)                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚  SYSTEM       â”‚ â”‚  INSTRUCTIONS â”‚ â”‚  USER         â”‚ â”‚  ASSISTANT    â”‚ â”‚
â”‚ â”‚  PROMPT       â”‚ â”‚  (auto-       â”‚ â”‚  MESSAGE      â”‚ â”‚  RESPONSE     â”‚ â”‚
â”‚ â”‚  (agent def)  â”‚ â”‚  injected)    â”‚ â”‚  (prompt +    â”‚ â”‚  (+ tool      â”‚ â”‚
â”‚ â”‚               â”‚ â”‚               â”‚ â”‚  context)     â”‚ â”‚  results)     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â–²                 â–²                 â–²                 â–²         â”‚
â”‚         â”‚                 â”‚                 â”‚                 â”‚         â”‚
â”‚   Agent File       Instruction Files   Prompt File +      Tool Calls + â”‚
â”‚   (.agent.md)      (.instructions.md)  Prompt-Snippets   MCP Results   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Component roles in information flow

Before designing communication strategies, understand **who contributes what** to the context window.

The tables below split components into **customization files** (what you author) and **tool sources** (where capabilities come from). This distinction matters for three reasons:

1. **Some components <mark>disappear after one use</mark>** (<mark>**short persistence**</mark>) â€” Prompt files are "single execution": once the task completes, their content is gone. If the next agent needs that information, <mark>you must explicitly transfer it during handoff</mark>.

2. **Some components are <mark>auto-included</mark>, others require action** â€” **Agent** files and **instruction** files (**<mark>System â†’ Model</mark>** files) <mark>are injected automatically</mark> by VS Code. Prompt files and snippet files (<mark>**User â†’ Model**</mark>) require you to <mark>invoke or reference them explicitly</mark>.

3. **<mark>Tool results</mark> consume tokens** (<mark>**bidirectional tools**</mark>) â€” When the model calls a tool and receives results, those results are added to the context window. Large file reads or search results can bloat context quickly.

### Customization components (what you create)

The table below describes GitHub Copilot customization files and how context information flows into the model. For each component:

- **Direction** tells you *how* it reaches the model: <mark>**User â†’ Model**</mark> means you include it explicitly; <mark>**System â†’ Model**</mark> means VS Code auto-injects it
- **Persistence** tells you *how long* it stays active â€” and whether you need to transfer it during handoffs

| Component | What It Provides | Direction | Persistence |
|-----------|-----------------|-----------|-------------|
| **<mark>Prompt File</mark>** | Task-specific instructions + variables | User â†’ Model | Single execution |
| **<mark>Agent File</mark>** | Persona + default tools + behavior | <mark>System â†’ Model</mark> | Session-wide |
| **<mark>Instruction File</mark>** | Coding standards + context rules | <mark>System â†’ Model</mark> (auto) | Pattern-matched |
| **<mark>Prompt-Snippet</mark>** | Reusable context fragments | User â†’ Model | On-demand |

### Tool sources (where capabilities come from)

Unlike customization components (which provide *instructions*), <mark>tool sources provide *actions* the model can execute</mark>. The table below shows where these capabilities come from and their token impact. For each source:

- **Direction** tells you *how* data flows: <mark>**Model â†” X**</mark> means bidirectional (results add to context, consuming tokens); <mark>**X â†’ Model**</mark> means one-way pull (lighter on tokens)

| Source | What It Provides | Direction | Persistence |
|--------|-----------------|-----------|-------------|
| **<mark>Built-in Tools</mark>** | VS Code actions (`read_file`, `semantic_search`, `create_file`) | <mark>Model â†” VS Code</mark> | Per-invocation |
| **<mark>MCP Server Tools</mark>** | Custom actions via MCP protocol | <mark>Model â†” Server</mark> | Connection lifetime |
| **<mark>MCP Resources</mark>** | External data access (configs, live data) | <mark>Server â†’ Model</mark> | On-demand |
| **<mark>MCP Prompts</mark>** | Reusable templates from server | <mark>Server â†’ Model</mark> | On-demand |

> **<mark>Key distinction</mark>**: <mark>Tools</mark> are **callable functions**. <mark>MCP servers</mark> are **containers** that provide <mark>tools</mark>, <mark>resources</mark>, and <mark>prompts</mark> via the MCP protocol. Built-in tools come from VS Code; custom tools come from MCP servers you configure.

Now that you understand *what* each component contributes and *when* it's active, the next sections explore *how* information flows between themâ€”the communication pathways that connect prompts to agents, agents to tools, and phases to each other.

### Information flow diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ORCHESTRATOR PROMPT                              â”‚
â”‚                     (coordinates workflow phases)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                     â”‚                     â”‚
         â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AGENT A         â”‚   â”‚ AGENT B         â”‚   â”‚ AGENT C         â”‚
â”‚ (researcher)    â”‚â”€â”€â–ºâ”‚ (builder)       â”‚â”€â”€â–ºâ”‚ (validator)     â”‚
â”‚                 â”‚   â”‚                 â”‚   â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚Instructions â”‚ â”‚   â”‚ â”‚Instructions â”‚ â”‚   â”‚ â”‚Instructions â”‚ â”‚
â”‚ â”‚(auto-inject)â”‚ â”‚   â”‚ â”‚(auto-inject)â”‚ â”‚   â”‚ â”‚(auto-inject)â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                 â”‚   â”‚                 â”‚   â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚Tools        â”‚ â”‚   â”‚ â”‚Tools        â”‚ â”‚   â”‚ â”‚Tools        â”‚ â”‚
â”‚ â”‚ â€¢ search    â”‚ â”‚   â”‚ â”‚ â€¢ create    â”‚ â”‚   â”‚ â”‚ â€¢ read      â”‚ â”‚
â”‚ â”‚ â€¢ fetch     â”‚ â”‚   â”‚ â”‚ â€¢ edit      â”‚ â”‚   â”‚ â”‚ â€¢ validate  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                 â”‚   â”‚                 â”‚   â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚MCP Servers  â”‚ â”‚   â”‚ â”‚MCP Servers  â”‚ â”‚   â”‚ â”‚MCP Servers  â”‚ â”‚
â”‚ â”‚ â€¢ iqpilot   â”‚ â”‚   â”‚ â”‚             â”‚ â”‚   â”‚ â”‚ â€¢ linter    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                     â”‚                     â”‚
         â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚
         â”‚    â”‚                â”‚                     â”‚
         â–¼    â–¼                â–¼                     â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              HANDOFF CONTEXT                          â”‚
    â”‚  (conversation history, reports, file references)     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

# ğŸ“¡ Communication pathways

## <mark>Prompt â†’ Agent</mark> communication

When a prompt file references an agent via the `agent` field, information flows in a specific priority order.

### Information priority chain

<mark>**Prompt > Agent > Default**</mark> â€” This is the fundamental rule for all configuration inheritance.

| Configuration | Priority | Example |
|--------------|----------|---------|
| Prompt `tools` | **Highest** | Prompt specifies `tools: ['fetch', 'codebase']` |
| Agent `tools` | **Medium** | Agent defines `tools: ['semantic_search', 'read_file']` |
| Default tools | **Lowest** | Built-in Copilot tools |

### How prompt invokes agent

```yaml
# review-security.prompt.md
---
name: security-review
agent: security-specialist    # â† References agent
tools: ['codebase', 'grep']   # â† Overrides agent's default tools
model: claude-sonnet-4        # â† Can override agent's model too
---

Review the following code for security vulnerabilities:

${selection}

Focus on: ${input:focus:What security aspect should I focus on?}
```

### What flows from prompt to agent

| Data | Flow Mechanism | Notes |
|------|----------------|-------|
| **Task instructions** | <mark>Prompt body â†’ User message</mark> | The <mark>main task description</mark> |
| **Variable values** | <mark>Substituted at runtime</mark> | `${selection}`, `${file}`, `${input:...}` |
| **Tool restrictions** | <mark>`tools` field override</mark> | Limits agent's available tools |
| **Model selection** | <mark>`model` field override</mark> | Changes from agent's default model |

### What agent provides

| Data | Source | Notes |
|------|--------|-------|
| **Persona/behavior** | <mark>Agent body (Markdown)</mark> | System message defining role |
| **Default tools** | <mark>Agent `tools` field</mark> | Available unless prompt overrides |
| **Handoff options** | <mark>Agent `handoffs` field</mark> | Buttons for workflow transitions |

---

## Agent â†’ Agent (handoffs)

Handoffs are the critical juncture where information can be lost or bloated.  
VS Code provides a <mark>**binary handoff mechanism**</mark>: either transfer the full conversation (`send: true`) or let the user control the handoff (`send: false`).

### Handoff configuration

```yaml
# builder.agent.md
---
name: builder
tools: ['create_file', 'replace_string_in_file']
handoffs:
  - label: "Validate Build"
    agent: validator
    send: true                  # â† Full conversation transfers
    prompt: |
      Validate the file created above.
      
      **Focus on** (from conversation above):
      - File structure correctness
      - Required sections present
      
      **Expected output format**:
      Validation report with PASS/FAIL status.
---
```

### What flows during handoff

| `send` Setting | Data Transferred | Token Impact |
|----------------|------------------|--------------|
| `send: true` | **<mark>Entire conversation history</mark>** | Highâ€”all prior phases included |
| <mark>`send: false`</mark> | **<mark>Nothing automatically</mark>** | <mark>User manually pastes context</mark> |

<mark>**Key Limitation**</mark>: VS Code does **not** support selective context filtering.  
You cannot specify "send only Phase 3 output" directly in the handoff configuration.

### Handoff data flow diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT A (Builder)                                              â”‚
â”‚                                                                 â”‚
â”‚  Conversation History:                                          â”‚
â”‚  â”œâ”€â”€ User request (Phase 1)           ~200 tokens               â”‚
â”‚  â”œâ”€â”€ Research report (Phase 2)        ~2,500 tokens             â”‚
â”‚  â”œâ”€â”€ Architecture spec (Phase 3)      ~1,500 tokens             â”‚
â”‚  â””â”€â”€ Built file content (Phase 4)     ~2,000 tokens             â”‚
â”‚                                        â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”‚
â”‚                                        ~6,200 tokens TOTAL       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     send: true            â”‚
                    â”‚                           â”‚
                    â–¼                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  AGENT B (Validator)        â”‚   â”‚  AGENT B (Validator)        â”‚
â”‚  send: true                 â”‚   â”‚  send: false                â”‚
â”‚                             â”‚   â”‚                             â”‚
â”‚  Receives:                  â”‚   â”‚  Receives:                  â”‚
â”‚  ALL 6,200 tokens           â”‚   â”‚  Only handoff prompt        â”‚
â”‚  + handoff prompt           â”‚   â”‚  (~100 tokens)              â”‚
â”‚                             â”‚   â”‚                             â”‚
â”‚  Total: ~6,300 tokens       â”‚   â”‚  User must paste context    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Instructions integration

Instructions are <mark>**automatically injected**</mark> based on file patternsâ€”you don't explicitly invoke them.

### How instructions flow

1. **Pattern matching**: VS Code evaluates <mark>`applyTo`</mark> glob patterns against current file context
2. **Automatic injection**: Matching instructions are added to the system prompt
3. **Cumulative application**: Multiple matching instructions combine (no guaranteed order)

```yaml
# react-guidelines.instructions.md
---
applyTo: "**/*.tsx,**/*.jsx"
description: "React component coding standards"
---

## React Component Guidelines

- Use functional components with TypeScript
- Define props interface before component
- Use React.FC<Props> for typing
```

### What instructions provide

| Data | Flow Mechanism | Visibility |
|------|----------------|------------|
| **<mark>Coding standards</mark>** | <mark>System prompt injection</mark> | Silent (not shown in chat) |
| **<mark>Tool suggestions</mark>** | `#tool:<tool-name>` references | Guides tool selection |
| **<mark>Best practices</mark>** | Markdown content | Applied to all matching files |

### Instructions don't control

| Aspect | Why Not | Alternative |
|--------|---------|-------------|
| **<mark>Tool restrictions</mark>** | Instructions can't limit tools | Use agent `tools` field |
| **<mark>Handoff behavior</mark>** | No handoff configuration | Use agent `handoffs` field |
| **<mark>Model selection</mark>** | No model field | Use prompt or agent `model` field |

---

## Tool invocations and results

Tools represent <mark>**bidirectional communication**</mark> between the model and external systems.

### Tool invocation flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     Request      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚                  â”‚
â”‚   AI MODEL       â”‚                  â”‚   TOOL           â”‚
â”‚   (Copilot)      â”‚                  â”‚   (e.g., fetch)  â”‚
â”‚                  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     Result       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What flows in tool invocation

| Direction | Data | Format |
|-----------|------|--------|
| **Request** (Model â†’ Tool) | <mark>Function name + arguments</mark> | JSON Schema validated |
| **Result** (Tool â†’ Model) | <mark>Structured output</mark> | Text, JSON, or multi-part content |

### Tool result handling

Tool results are <mark>**added to the conversation context**</mark> and consume tokens.  
Large tool results (like full file reads or extensive search results) can quickly bloat the context.

```markdown
## Tool Result Impact on Context

| Tool | Typical Result Size | Context Impact |
|------|--------------------|--------------------|
| `read_file` (50 lines) | ~500 tokens | Low |
| `read_file` (500 lines) | ~5,000 tokens | High |
| `semantic_search` (10 results) | ~2,000 tokens | Medium |
| `fetch_webpage` | ~3,000-10,000 tokens | Very High |
| `grep_search` (20 matches) | ~1,500 tokens | Medium |
```

### Best practices for tool result handling

1. **<mark>Request specific line ranges</mark>** for `read_file` instead of entire files
2. **<mark>Limit search results</mark>** using `maxResults` parameter
3. **<mark>Summarize large results</mark>** in intermediary reports before handoffs
4. **<mark>Use `#tool:` references</mark>** to suggest but not mandate tool use

### Terminal command boundaries

The `run_in_terminal` tool requires special attention because it can execute **arbitrary shell commands**.

> âš ï¸ **Warning**: Always define explicit boundaries for agents with `run_in_terminal` access to prevent unintended system modifications.

**Safe patterns**:
```yaml
# In agent instructions:
## Terminal Usage Boundaries

**ALLOWED commands**:
- `npm install`, `npm run build`, `npm test`
- `dotnet build`, `dotnet test`
- `git status`, `git diff`

**NEVER execute**:
- `rm -rf`, `del /s`, or any recursive deletion
- Commands that modify system configuration
- Commands that access credentials or secrets
```

**Best practice**: Create separate agents with restricted tool accessâ€”don't give `run_in_terminal` to agents that don't need it.

---

## <mark>VS Code tasks</mark> and <mark>terminal commands</mark>

VS Code tasks (defined in `.vscode/tasks.json`) are **<mark>not directly accessible</mark>** to agents or prompts.  
However, agents can achieve similar automation outcomes through other mechanisms.

| Approach | Use Case | Tool Required |
|----------|----------|---------------|
| **<mark>Terminal commands</mark>** | Run build scripts, npm/dotnet commands | `run_in_terminal` |
| **<mark>MCP server actions</mark>** | Execute complex build workflows | Custom MCP tool |
| **<mark>Pre-workflow setup</mark>** | Ensure environment is ready | User runs task manually |

> **<mark>Note</mark>**: If your workflow requires build automation, consider creating an MCP server that wraps your build commands with proper error handling and status reporting.

---

## MCP server communication

MCP (Model Context Protocol) enables <mark>**external server communication**</mark> with tools, resources, and prompts.

### <mark>MCP communication flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VS CODE (MCP Host)                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  MCP Client                                              â”‚   â”‚
â”‚  â”‚  (manages connection)                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                 â”‚                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚ stdio or HTTP
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MCP SERVER (e.g., IQPilot)                                     â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚   TOOLS      â”‚  â”‚  RESOURCES   â”‚  â”‚   PROMPTS    â”‚          â”‚
â”‚  â”‚  â€¢ validate  â”‚  â”‚  â€¢ config    â”‚  â”‚  â€¢ templates â”‚          â”‚
â”‚  â”‚  â€¢ analyze   â”‚  â”‚  â€¢ cache     â”‚  â”‚              â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### What <mark>flows with MCP</mark>

| Primitive | Flow Direction | Data |
|-----------|----------------|------|
| **<mark>Tools</mark>** | <mark>Request â†’ Execution â†’ Result</mark> | Function calls with JSON Schema args |
| **<mark>Resources</mark>** | <mark>Request â†’ Data</mark> | File contents, configurations, live data |
| **<mark>Prompts</mark>** | <mark>Discovery â†’ Template</mark> | Reusable prompt templates |

### MCP configuration in agents

```yaml
# specialist.agent.md (for github-copilot target)
---
name: specialist
target: github-copilot
mcp-servers:
  - name: iqpilot
    command: dotnet
    args: ["run", "--project", "src/IQPilot"]
---
```

### MCP result handling

MCP results follow the same pattern as tool resultsâ€”they're added to context and consume tokens.  
Unlike built-in tools, MCP servers can return <mark>**rich, multi-part content**</mark>:

```json
{
  "content": [
    { "type": "text", "text": "Analysis complete..." },
    { "type": "resource", "uri": "file:///report.md" },
    { "type": "image", "data": "base64...", "mimeType": "image/png" }
  ]
}
```

---

## <mark>Prompt-snippet</mark> inclusion

Prompt-snippets are <mark>**reusable context fragments**</mark> that you include on-demand using file references.

### How to include snippets

```markdown
# In your prompt file or chat message:

Analyze this code following our security standards.

#file:.github/prompt-snippets/security-checklist.md

Review the code: ${selection}
```

### What snippets provide

| Use Case | Example Snippet | Benefit |
|----------|-----------------|---------|
| **<mark>Checklists</mark>** | `security-checklist.md` | Consistent validation criteria |
| **<mark>Domain glossaries</mark>** | `api-terminology.md` | Shared vocabulary |
| **<mark>Architecture summaries</mark>** | `system-overview.md` | Context without full docs |
| **<mark>Output templates</mark>** | `report-format.md` | Consistent output structure |

### Snippet organization

```
.github/prompt-snippets/
â”œâ”€â”€ checklists/
â”‚   â”œâ”€â”€ security-review.md
â”‚   â”œâ”€â”€ code-quality.md
â”‚   â””â”€â”€ documentation.md
â”œâ”€â”€ context/
â”‚   â”œâ”€â”€ architecture-overview.md
â”‚   â”œâ”€â”€ api-patterns.md
â”‚   â””â”€â”€ coding-standards-summary.md
â””â”€â”€ templates/
    â”œâ”€â”€ validation-report.md
    â””â”€â”€ implementation-plan.md
```

### Snippets vs instructions

| Aspect | Prompt-Snippets | Instructions |
|--------|-----------------|--------------|
| **<mark>Activation</mark>** | Manual (`#file:...`) | Automatic (`applyTo` pattern) |
| **<mark>Visibility</mark>** | Explicit in prompt | Silent injection |
| **<mark>Use case</mark>** | Task-specific context | Universal coding standards |
| **<mark>Token control</mark>** | Full control (include only when needed) | Always included for matching files |

---

# ğŸ“Š Communication strategies comparison

## Strategy comparison matrix

| Strategy | Token Efficiency | Robustness | Complexity | Best For |
|----------|-----------------|------------|------------|----------|
| **<mark>Full Context</mark>** (`send: true`) | <mark>âš ï¸ Low</mark> | âœ… High | âœ… Low | Simple 2-3 phase workflows |
| **<mark>Progressive Summarization</mark>** | âœ… Medium | âœ… Medium-High | <mark>âš ï¸ Medium</mark> | Multi-phase workflows (3-5 phases) |
| **<mark>File-Based Isolation</mark>** | âœ… High | âš ï¸ Medium | âš ï¸ Medium | Specialized single-purpose agents |
| **<mark>User-Mediated Handoff</mark>** | âœ… Maximum | âš ï¸ Variable | âš ï¸ High (user effort) | Maximum control needed |
| **<mark>Structured Report Passing</mark>** | <mark>âœ… Medium-High</mark> | âœ… High | âš ï¸ Medium | Complex orchestrations |

## Token efficiency analysis

### Cumulative token cost by strategy

```
Phase 1 (200) â”€â”€â”€â”€â–º Phase 2 (2,500) â”€â”€â”€â”€â–º Phase 3 (4,000) â”€â”€â”€â”€â–º Phase 4 (6,000) â”€â”€â”€â”€â–º Phase 5 (8,000)

FULL CONTEXT (send: true on each handoff):
â”œâ”€â”€ P1â†’P2:    200 + 2,300 =  2,500 tokens
â”œâ”€â”€ P2â†’P3:  2,500 + 1,500 =  4,000 tokens
â”œâ”€â”€ P3â†’P4:  4,000 + 2,000 =  6,000 tokens
â”œâ”€â”€ P4â†’P5:  6,000 + 2,000 =  8,000 tokens
â”‚
â””â”€â”€ TOTAL INPUT: ~20,500 tokens across all phases

PROGRESSIVE SUMMARIZATION:
â”œâ”€â”€ P1â†’P2:    200 + 2,300 =  2,500 tokens
â”œâ”€â”€ P2â†’P3:    500 + 1,500 =  2,000 tokens (summarized P2)
â”œâ”€â”€ P3â†’P4:    600 + 2,000 =  2,600 tokens (summarized P3)
â”œâ”€â”€ P4â†’P5:    700 + 2,000 =  2,700 tokens (summarized P4)
â”‚
â””â”€â”€ TOTAL INPUT: ~9,800 tokens across all phases (52% reduction)

FILE-BASED ISOLATION:
â”œâ”€â”€ P1â†’P2:    200 + 2,300 =  2,500 tokens
â”œâ”€â”€ P2â†’P3:    300 (file ref) = 300 tokens
â”œâ”€â”€ P3â†’P4:    300 (file ref) = 300 tokens
â”œâ”€â”€ P4â†’P5:    300 (file ref) = 300 tokens
â”‚
â””â”€â”€ TOTAL INPUT: ~3,400 tokens across all phases (83% reduction)
```

## Robustness comparison

### Information preservation by strategy

| Strategy | Goal Preserved | Scope Preserved | Critical Data | Recovery if Lost |
|----------|---------------|-----------------|---------------|------------------|
| **Full Context** | âœ… Always | âœ… Always | âœ… Always | N/A (everything present) |
| **Progressive Summary** | âœ… Explicit in summary | âœ… If included | âš ï¸ Depends on summary quality | Re-summarize from previous output |
| **File-Based** | âš ï¸ Must be in file | âš ï¸ Must be in file | âš ï¸ Must be in file | Read file for recovery |
| **User-Mediated** | âš ï¸ User must include | âš ï¸ User must include | âš ï¸ User controls | User re-pastes |

### Risk mitigation

```markdown
## Reliability Checksum Pattern

Before each handoff, validate that critical data survives:

- [ ] **Goal Preservation**: Refined goal from Phase 1 still intact?
- [ ] **Scope Boundaries**: IN/OUT scope still clear?
- [ ] **Tool Requirements**: Tool list carried forward?
- [ ] **Critical Constraints**: Boundaries included in handoff?
- [ ] **Success Criteria**: Validation criteria defined?

**If any checkbox fails**: Re-inject missing context before handoff.
```

---

# ğŸ”§ Implementation patterns

## Pattern 1: <mark>Full context handoff</mark>

**Best for**: Simple 2-3 phase workflows where token cost is acceptable.

```yaml
# orchestrator.prompt.md
---
name: simple-workflow
agent: orchestrator
handoffs:
  - label: "Build Component"
    agent: builder
    send: true       # Full context transfers
    prompt: |
      Create the component based on the requirements discussed above.
      
      Implement all features from the specification.
---
```

**Pros**:
- âœ… No context loss risk
- âœ… Simple to implement
- âœ… Agent has complete history

**Cons**:
- âš ï¸ High token cost
- âš ï¸ Context bloat in long workflows
- âš ï¸ May exceed context window

---

## Pattern 2: <mark>Progressive summarization</mark>

**Best for**: Multi-phase workflows (3-5 phases) requiring context but controlling tokens.

```yaml
# At end of each phase, instruct agent to produce a summary:

## Phase Completion Instructions

When completing this phase, produce a **PHASE SUMMARY** block:

\`\`\`markdown
## Phase {N} Summary

**Key Outputs**:
- [Output 1]: {1-sentence description}
- [Output 2]: {1-sentence description}

**Critical Data** (preserve in next phase):
- Goal: "{quote the refined goal}"
- Scope: IN=[list], OUT=[list]

**For Next Phase**:
- {Specific instruction 1}
- {Specific instruction 2}
\`\`\`
```

**Handoff using summary**:

```yaml
handoffs:
  - label: "Continue to Build"
    agent: builder
    send: true
    prompt: |
      Build from the **Phase 2 Summary** above.
      
      **FOCUS ON** the "Key Outputs" and "Critical Data" sections.
      **IGNORE** the detailed research processâ€”only the summary matters.
```

---

## Pattern 3: <mark>File-based isolation</mark>

**Best for**: Specialized agents that need minimal context.

### Step 1: Write context to file

```yaml
# research-agent.agent.md
---
name: researcher
tools: ['read_file', 'write_file', 'semantic_search']
---

## Output Requirements

After completing research, write findings to:
`.copilot/temp/{timestamp}-research-spec.md`

Include:
- All key patterns discovered
- Template recommendations
- Critical constraints
- Success criteria

This file will be the ONLY input for the builder agent.
```

### Step 2: <mark>Handoff references file</mark>

```yaml
handoffs:
  - label: "Build from Specification"
    agent: builder
    send: false      # Don't send conversation
    prompt: |
      Read the build specification from `.copilot/temp/latest-spec.md`
      and create the file according to that specification.
      
      Ignore any other contextâ€”the spec file contains everything you need.
```

**File location convention**:
- **Path**: `.copilot/temp/` (add to `.gitignore`)
- **Naming**: `{ISO-timestamp}-{phase}-{topic}.md`
- **Cleanup**: Delete after workflow completes or after 24 hours

---

## Pattern 4: <mark>User-mediated handoff</mark>

**Best for**: Maximum control and token efficiency when user effort is acceptable.

```yaml
handoffs:
  - label: "Validate Prompt"
    agent: validator
    send: false      # User decides what to share
```

**Workflow**:

1. Orchestrator completes Phase 3, produces specification
2. User sees: "Ready to validate. Click 'Validate Prompt' to continue."
3. User clicks handoff button
4. **New chat session opens** with validator agent
5. User pastes **only the specification** (not full history)
6. Validator works with minimal context

---

## Pattern 5: <mark>Structured report passing</mark>

**Best for**: Complex orchestrations requiring explicit data contracts.

### Define data contract

```yaml
# In orchestrator instructions:

## Phase-to-Phase Data Contracts

### Phase 2 â†’ Phase 3
**Researcher** must output:
- Pattern list (3-5 items with file references)
- Template recommendation
- Anti-patterns to avoid

**Architect** expects to receive:
- Pattern summary (not full analysis)
- Recommended template path
- Constraint list

### Phase 3 â†’ Phase 4
**Architect** must output:
- Specification document
- Tool requirements (explicit list)
- Success criteria (measurable)

**Builder** expects to receive:
- Specification (complete)
- Tool list (validated against available tools)
- Validation criteria
```

### Handoff template

```yaml
handoffs:
  - label: "Build from Specification"
    agent: builder
    send: true
    prompt: |
      {Primary Task Statement - 1 sentence}
      
      **CONTEXT FROM PREVIOUS PHASE** (reference above):
      - Specification: See Phase 3 output
      - Tools required: {list from spec}
      
      **YOUR SPECIFIC INPUTS**:
      - Template: {path from architect}
      - Constraints: {list from architect}
      
      **EXPECTED OUTPUT FORMAT**:
      - Created file path
      - Implementation notes
      - Validation readiness status
      
      **SUCCESS CRITERIA**:
      - All specification requirements met
      - File passes linting
      - Ready for validation phase
```

---

# âš ï¸ Common pitfalls and solutions

## Pitfall 1: Context loss during handoffs

**Problem**: Critical information from earlier phases gets lost.

**âŒ Bad example**:
```yaml
handoffs:
  - label: "Test"
    agent: test-specialist
    prompt: "Write tests"
```

**Problem**: Test specialist doesn't know what was implemented or what requirements to validate.

**âœ… Solution**:
```yaml
handoffs:
  - label: "Generate Tests"
    agent: test-specialist
    send: true
    prompt: |
      Create comprehensive tests for the implementation discussed above.
      
      **Validate requirements** from the research phase.
      **Cover edge cases** documented during planning.
      **Reference implementation** from the builder's output.
```

---

## Pitfall 2: Token bloat from tool results

**Problem**: Large tool results consume excessive context.

**âŒ Bad example**:
```markdown
Read the entire file for context.
#tool:read_file path="/path/to/large-file.ts"
```

**âœ… Solution**:
```markdown
Read only the relevant section (lines 50-100).
#tool:read_file path="/path/to/large-file.ts" startLine=50 endLine=100
```

---

## Pitfall 3: Instruction conflicts

**Problem**: Multiple instruction files provide contradictory guidance.

**Scenario**:
- `python-standards.instructions.md` says: "Use 4-space indentation"
- `team-conventions.instructions.md` says: "Use 2-space indentation"

**âœ… Solution**:
1. **Use specific `applyTo` patterns** to avoid overlaps
2. **Create hierarchy** with base instructions and specific overrides
3. **Document precedence** in a parent instruction file

```yaml
# base-standards.instructions.md
---
applyTo: "**/*"
---

## Base Standards
These are default standards. More specific instruction files override these.
```

---

## Pitfall 4: MCP timeout and error handling

**Problem**: MCP server calls can fail or timeout, breaking workflows.

**âœ… Solution**: Design prompts with fallback instructions:

```markdown
## MCP Tool Usage

Try to use #tool:mcp_iqpilot_validate to validate the article.

**If the tool is unavailable or times out**:
- Perform manual validation using the checklist below
- Note that MCP validation was skipped
- Recommend running MCP validation later

### Manual Validation Checklist
- [ ] YAML frontmatter present and valid
- [ ] Required sections (intro, conclusion, references)
- [ ] References properly classified
```

---

# ğŸ’¡ Best practices and guidelines

## Token budget management

### Estimate before handoff

| Workflow Phase | Typical Output | Token Estimate |
|----------------|----------------|----------------|
| Requirements gathering | User request + clarifications | 200-500 tokens |
| Research/discovery | Pattern analysis, recommendations | 2,000-4,000 tokens |
| Architecture/planning | Specifications, designs | 1,500-3,000 tokens |
| Building/implementation | Created code/content | 1,000-5,000 tokens |
| Validation | Check results, issues | 500-1,500 tokens |

### Set phase budgets

```markdown
## Phase Budget Guidelines

| Phase | Target Max | Action if Exceeded |
|-------|-----------|-------------------|
| Research | 3,000 tokens | Summarize to 1,000 tokens before handoff |
| Architecture | 2,000 tokens | Split into multiple specs if larger |
| Build | 4,000 tokens | Use file-based output, reference by path |
| Validation | 1,500 tokens | Compress to issues-only report |
```

## Testing information flow

### Information flow checklist

Before deploying a multi-agent workflow:

1. **Trace critical data path**: Follow the most important data point through every phase
2. **Verify handoff completeness**: Ensure each handoff prompt references required prior outputs
3. **Test with minimal input**: Run workflow with shortest possible valid input
4. **Measure token consumption**: Track tokens at each phase boundary
5. **Simulate failures**: What happens if a tool fails? If an agent can't complete?

### Debug logging pattern

```markdown
## Phase {N} Completion

### Debug Information
- **Phase started**: {timestamp}
- **Phase completed**: {timestamp}
- **Tokens consumed** (estimate): {count}
- **Tools invoked**: {list}
- **MCP calls**: {list}

### Context Verification
- Goal from Phase 1: "{quote or 'MISSING'}"
- Scope boundaries: "{quote or 'MISSING'}"
- Critical constraints: "{quote or 'MISSING'}"

### Handoff Readiness
- [ ] Output format matches contract
- [ ] Required data preserved
- [ ] No unresolved blockers
```

---

# ğŸ¯ Conclusion

## Key takeaways

Managing information flow in prompt orchestrations requires understanding:

1. **<mark>The context window is your communication bus</mark>** â€” All components share this limited space
2. **<mark>Handoffs are the critical junctures</mark>** â€” Design them explicitly with data contracts
3. **<mark>Token efficiency compounds</mark>** â€” Small savings per phase add up significantly
4. **<mark>Robustness requires explicit preservation</mark>** â€” Critical data must be actively carried forward
5. **<mark>Each component has a specific role</mark>** â€” Use the right mechanism for each type of data

## Decision framework

| Scenario | Recommended Strategy |
|----------|---------------------|
| Simple 2-3 phase workflow | Full context (`send: true`) |
| Multi-phase (3-5 phases) | Progressive summarization |
| Long workflow (5+ phases) | File-based isolation |
| Maximum control needed | User-mediated handoff |
| Complex data contracts | Structured report passing |
| Mix of above | Combine strategies per phase |

## Next steps

To apply these patterns:

1. **Audit existing workflows** for context loss or bloat
2. **Implement reliability checksum** before each handoff
3. **Measure token consumption** and set budgets
4. **Design explicit data contracts** between agents
5. **Test failure scenarios** and add fallback instructions

For related topics, see:
- [How to Create a Prompt Orchestrating Multiple Agents](./20-how_to_create_a_prompt_interacting_with_agents.md) â€” Detailed orchestrator design, including execution contexts (Local, Background, Cloud) that affect information isolation
- [How to Structure Content for GitHub Copilot Agent Files](./04.00-how_to_structure_content_for_copilot_agent_files.md) â€” Agent file structure and handoff configuration
- [How to Create MCP Servers for GitHub Copilot](./07.00-how_to_create_mcp_servers_for_copilot.md) â€” MCP server implementation and tool development

> **Execution contexts note**: Information flow differs across VS Code's three execution contexts (Local, Background, Cloud). Local agents modify workspace directly; Background agents use isolated Git worktrees; Cloud agents create separate branches and PRs. See article 10 appendix for details.

---

# ğŸ“š References

## Official documentation

**[VS Code: Customize Chat to Your Workflow](https://code.visualstudio.com/docs/copilot/copilot-customization)** ğŸ“˜ [Official]  
Comprehensive overview of VS Code Copilot customization options including custom instructions, prompt files, agents, and MCP integration. Essential reading for understanding how all customization types work together.

**[VS Code: Custom Agents Documentation](https://code.visualstudio.com/docs/copilot/copilot-customization#_custom-agents)** ğŸ“˜ [Official]  
Official documentation on creating custom agents in VS Code, including handoff configuration and tool restrictions. Primary reference for agent file structure.

**[Model Context Protocol: Architecture Overview](https://modelcontextprotocol.io/docs/concepts/architecture)** ğŸ“˜ [Official]  
Official MCP specification covering the client-server architecture, primitives (tools, resources, prompts), and communication protocols. Essential for understanding MCP server integration.

**[Model Context Protocol: Server Concepts](https://modelcontextprotocol.io/docs/learn/server-concepts)** ğŸ“˜ [Official]  
Detailed documentation on MCP server primitives and how they provide context to AI applications. Covers tool discovery, execution, and result handling.

## Verified community resources

**[GitHub Blog: How to Write a Great AGENTS.md](https://github.blog/ai-and-ml/github-copilot/how-to-write-a-great-agents-md-lessons-from-over-2500-repositories/)** ğŸ“— [Verified Community]  
Analysis of 2,500+ repositories with AGENTS.md files, extracting best practices for agent instructions. Valuable for understanding real-world patterns.

## Internal references

**[Handoffs Pattern for Multi-Agent Orchestration](../../.copilot/context/00.00-prompt-engineering/04-handoffs-pattern.md)** ğŸ“’ [Internal]  
Repository context file defining handoff patterns, intermediary report formats, and anti-patterns. Primary internal reference for orchestration design.

**[How to Create a Prompt Orchestrating Multiple Agents](./20-how_to_create_a_prompt_interacting_with_agents.md)** ğŸ“’ [Internal]  
Detailed article on orchestrator design with phase-based coordination and information exchange protocols. Covers implementation patterns and common mistakes.

---

<!-- 
---
validations:
  grammar:
    last_run: null
    model: null
    outcome: null
    issues_found: 0
  
  readability:
    last_run: null
    model: null
    outcome: null
    flesch_score: null
    grade_level: null
  
  understandability:
    last_run: null
    model: null
    outcome: null
    target_audience: "intermediate-advanced"
  
  structure:
    last_run: null
    model: null
    outcome: null
    has_toc: true
    has_introduction: true
    has_conclusion: true
    has_references: true
    heading_structure: "H1 > H2 > H3"
  
  facts:
    last_run: null
    model: null
    outcome: null
    claims_checked: 0
    sources_verified: 0
    sources: []
  
  logic:
    last_run: null
    model: null
    outcome: null
    flow_score: null

article_metadata:
  filename: "09.00 how_to_manage_information_flow_during_prompt_orchestrations.md"
  created: "2026-01-25"
  last_updated: "2026-01-25"
  version: "1.0"
  status: "draft"
  word_count: 4200
  reading_time_minutes: 18
  primary_topic: "information-flow"
  series: "GitHub Copilot Prompt Engineering"
  series_order: 9

cross_references:
  related_articles:
    - "04.00 how_to_structure_content_for_copilot_agent_files.md"
    - "07.00 how_to_create_mcp_servers_for_copilot.md"
    - "10. how_to_create_a_prompt_interacting_with_agents.md"
  series: "Prompt Engineering Series"
  prerequisites:
    - "01.00 how_github_copilot_uses_markdown_and_prompt_folders.md"
    - "02.00 how_to_name_and_organize_prompt_files.md"
    - "03.00 how_to_structure_content_for_copilot_prompt_files.md"
---
-->
